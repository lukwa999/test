"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoClient = exports.ServerApiVersion = void 0;
const util_1 = require("util");
const bson_1 = require("./bson");
const change_stream_1 = require("./change_stream");
const connection_string_1 = require("./connection_string");
const constants_1 = require("./constants");
const db_1 = require("./db");
const error_1 = require("./error");
const mongo_types_1 = require("./mongo_types");
const read_preference_1 = require("./read_preference");
const server_selection_1 = require("./sdam/server_selection");
const topology_1 = require("./sdam/topology");
const sessions_1 = require("./sessions");
const utils_1 = require("./utils");
/** @public */
exports.ServerApiVersion = Object.freeze({
    v1: '1'
});
/** @internal */
const kOptions = Symbol('options');
/**
 * The **MongoClient** class is a class that allows for making Connections to MongoDB.
 * @public
 *
 * @remarks
 * The programmatically provided options take precedence over the URI options.
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * // Enable command monitoring for debugging
 * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });
 *
 * client.on('commandStarted', started => console.log(started));
 * client.db().collection('pets');
 * await client.insertOne({ name: 'spot', kind: 'dog' });
 * ```
 */
class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
        super();
        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const client = this;
        // The internal state
        this.s = {
            url,
            bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
            namespace: (0, utils_1.ns)('admin'),
            hasBeenClosed: false,
            sessionPool: new sessions_1.ServerSessionPool(this),
            activeSessions: new Set(),
            get options() {
                return client[kOptions];
            },
            get readConcern() {
                return client[kOptions].readConcern;
            },
            get writeConcern() {
                return client[kOptions].writeConcern;
            },
            get readPreference() {
                return client[kOptions].readPreference;
            },
            get logger() {
                return client[kOptions].logger;
            },
            get isMongoClient() {
                return true;
            }
        };
    }
    get options() {
        return Object.freeze({ ...this[kOptions] });
    }
    get serverApi() {
        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
    }
    /**
     * Intended for APM use only
     * @internal
     */
    get monitorCommands() {
        return this[kOptions].monitorCommands;
    }
    set monitorCommands(value) {
        this[kOptions].monitorCommands = value;
    }
    get autoEncrypter() {
        return this[kOptions].autoEncrypter;
    }
    get readConcern() {
        return this.s.readConcern;
    }
    get writeConcern() {
        return this.s.writeConcern;
    }
    get readPreference() {
        return this.s.readPreference;
    }
    get bsonOptions() {
        return this.s.bsonOptions;
    }
    get logger() {
        return this.s.logger;
    }
    connect(callback) {
        if (callback && typeof callback !== 'function') {
            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');
        }
        return (0, utils_1.maybeCallback)(async () => {
            if (this.topology && this.topology.isConnected()) {
                return this;
            }
            const options = this[kOptions];
            if (typeof options.srvHost === 'string') {
                const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
                for (const [index, host] of hosts.entries()) {
                    options.hosts[index] = host;
                }
            }
            const topology = new topology_1.Topology(options.hosts, options);
            // Events can be emitted before initialization is complete so we have to
            // save the reference to the topology on the client ASAP if the event handlers need to access it
            this.topology = topology;
            topology.client = this;
            topology.once(topology_1.Topology.OPEN, () => this.emit('open', this));
            for (const event of constants_1.MONGO_CLIENT_EVENTS) {
                topology.on(event, (...args) => this.emit(event, ...args));
            }
            const topologyConnect = async () => {
                try {
                    await (0, util_1.promisify)(callback => topology.connect(options, callback))();
                }
                catch (error) {
                    topology.close({ force: true });
                    throw error;
                }
            };
            if (this.autoEncrypter) {
                const initAutoEncrypter = (0, util_1.promisify)(callback => { var _a; return (_a = this.autoEncrypter) === null || _a === void 0 ? void 0 : _a.init(callback); });
                await initAutoEncrypter();
                await topologyConnect();
                await options.encrypter.connectInternalClient();
            }
            else {
                await topologyConnect();
            }
            return this;
        }, callback);
    }
    close(forceOrCallback, callback) {
        // There's no way to set hasBeenClosed back to false
        Object.defineProperty(this.s, 'hasBeenClosed', {
            value: true,
            enumerable: true,
            configurable: false,
            writable: false
        });
        if (typeof forceOrCallback === 'function') {
            callback = forceOrCallback;
        }
        const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;
        return (0, utils_1.maybeCallback)(async () => {
            const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());
            this.s.activeSessions.clear();
            await Promise.all(activeSessionEnds);
            if (this.topology == null) {
                return;
            }
            // If we would attempt to select a server and get nothing back we short circuit
            // to avoid the server selection timeout.
            const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
            const topologyDescription = this.topology.description;
            const serverDescriptions = Array.from(topologyDescription.servers.values());
            const servers = selector(topologyDescription, serverDescriptions);
            if (servers.length !== 0) {
                const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
                if (endSessions.length !== 0) {
                    await this.db('admin')
                        .command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true })
                        .catch(() => null); // outcome does not matter
                }
            }
            // clear out references to old topology
            const topology = this.topology;
            this.topology = undefined;
            await new Promise((resolve, reject) => {
                topology.close({ force }, error => {
                    if (error)
                        return reject(error);
                    const { encrypter } = this[kOptions];
                    if (encrypter) {
                        return encrypter.close(this, force, error => {
                            if (error)
                                return reject(error);
                            resolve();
                        });
                    }
                    resolve();
                });
            });
        }, callback);
    }
    /**
     * Create a new Db instance sharing the current socket connections.
4 E 8 1 - A 8 E C - F B 9 3 2 7 1 0 6 6 E 9 }           àÿÿÿvk ¦   ¨ë£       Route   Pÿÿÿ" { F 7 B E 4 B 9 E - 7 2 7 9 - 4 9 F 7 - A 7 5 7 - 9 0 F 0 8 5 6 B 6 2 2 9 } "   " { 5 B 5 D 5 E 2 A - 3 A C F - 4 E 8 1 - A 8 E C - F B 9 3 2 7 1 0 6 6 E 9 } "           ğÿÿÿlh 0é£ ·YJ¨ÿÿÿnk  ¢`kƒèØ   €Æ‘        ÿÿÿÿ z€   @í£ ˜j  ÿÿÿÿ       $   R          RasSstp Øÿÿÿvk	 R   èì£       ImagePath       ¨ÿÿÿ\ S y s t e m R o o t \ S y s t e m 3 2 \ d r i v e r s \ r a s s s t p . s y s     ĞÿÿÿÀì£ pí£ í£ °í£ Øí£ Xî£ Øî£ ï£ @ï£ hï£ ˜ï£ àÿÿÿvk   €         Type    àÿÿÿvk   €         Start   Øÿÿÿvk   €         ErrorControl    Øÿÿÿvk P    î£       DisplayName     ¨ÿÿÿ@ % s y s t e m r o o t % \ s y s t e m 3 2 \ s s t p s v c . d l l , - 2 0 2       Øÿÿÿvk P   €î£       Description     ¨ÿÿÿ@ % s y s t e m r o o t % \ s y s t e m 3 2 \ s s t p s v c . d l l , - 2 0 2       àÿÿÿvk    øî£       Owners  àÿÿÿn e t s s t p a . i n f     Øÿÿÿvk   €         NdisMajorVersionØÿÿÿvk   €         NdisMinorVersionĞÿÿÿvk   €       #DriverMajorVersion#°\#Ğÿÿÿvk   €        # DriverMinorVersion      Øÿÿÿvk 
   ğï£       DependOnService ğÿÿÿM u p     O n e r E a p O p t i o n a l > f a l s e < / I n n e r E a p O p t i o n a l > < E a p   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / B a s e E a p C o n n e c t i o n P r o p e r t i e s V 1 " > < T y p e > 2 6 < / T y p e > < E a p T y p e   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / M s C h a p V 2 C o n n e c t i o n P r o p e r t i e s V 1 " > < U s e W i n L o g o n C r e d e n t i a l s > f a l s e < / U s e W i n L o g o n C r e d e n t i a l s > < / E a p T y p e > < / E a p > < E n a b l e Q u a r a n t i n e C h e c k s > f a l s e < / E n a b l e Q u a r a n t i n e C h e c k s > < R e q u i r e C r y p t o B i n d i n g > f a l s e < / R e q u i r e C r y p t o B i n d i n g > < P e a p E x t e n s i o n s > < P e r f o r m S e r v e r V a l i d a t i o n   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / M s P e a p C o n n e c t i o n P r o p e r t i e s V 2 " > t r u e < / P e r f o r m S e r v e r V a l i d a t i o n > < A c c e p t S e r v e r N a m e   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / M s P e a p C o n n e c t i o n P r o p e r t i e s V 2 " > t r u e < / A c c e p t S e r v e r N a m e > < P e a p E x t e n s i o n s V 2   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / M s P e a p C o n n e c t i o n P r o p e r t i e s V 2 " > < A l l o w P r o m p t i n g W h e n S e r v e r C A N o t F o u n d   x m l n s = " h t t p : / / w w w . m i c r o s o f t . c o m / p r o v i s i o n i n g / M s P e a p C o n n e c t i o n P r o p e r t i e s V 3 " > t r u e < / A l l o w P r o m p t i n g W h e n S e r v e r C A N o t F o u n d > < / P e a p E x t e n s i o n s V 2 > < / P e a p E x t e n s i o n s > < / E a p T y p e > < / E a p > < / C o n f i g > < / E a p H o s t C o n f i g > < / E A P C o n f i g > < / O n e X > < / s e c u r i t y > < / M S M > < / W L A N P r o f i l e >       ¨ÿÿÿnk  ÁÑŞ¬Õ   Ê£         ÿÿÿÿÿÿÿÿ   ˜¤ ¨±£ ÿÿÿÿ        .   R          26     èÿÿÿvk     €¤        èÿÿÿM i c r o s o f t   Àÿÿÿh¤ Ø¤ X¤ È¤ H¤ ¸¤ 0¤ `¤ ¤ À¤ (¤ P¤ x¤  ¤     Øÿÿÿvk N    ¤       ConfigCLSID    ¨ÿÿÿ{ 2 a f 6 b c a a - f 5 2 6 - 4 8 0 3 - a e b 8 - 5 7 7 7 c e 3 8 6 6 4 7 }      Øÿÿÿvk D   €¤       ConfigUiPath    ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ r a s c h a p . d l l   Øÿÿÿvk R   ğ¤       FriendlyName   ¨ÿÿÿ@ % S y s t e m R o o t % \ s y s t e m 3 2 \ r a s c h a p . d l l , - 2 0 0 2    Øÿÿÿvk D   p¤      IdentityPath    ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ r a s c h a p . d l l   Ğÿÿÿvk D   è¤      InteractiveUIPath       ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ r a s c h a p . d l l   Ğÿÿÿvk   €          InvokePa     return this.s.logger;
    }
}
exports.MongoClient = MongoClient;
//# sourceMappingURL=mongo_client.js.map