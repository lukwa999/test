"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerCapabilities = exports.Topology = void 0;
const Denque = require("denque");
const timers_1 = require("timers");
const util_1 = require("util");
const bson_1 = require("../bson");
const connection_string_1 = require("../connection_string");
const constants_1 = require("../constants");
const error_1 = require("../error");
const mongo_types_1 = require("../mongo_types");
const read_preference_1 = require("../read_preference");
const utils_1 = require("../utils");
const common_1 = require("./common");
const events_1 = require("./events");
const server_1 = require("./server");
const server_description_1 = require("./server_description");
const server_selection_1 = require("./server_selection");
const srv_polling_1 = require("./srv_polling");
const topology_description_1 = require("./topology_description");
// Global state
let globalTopologyCounter = 0;
const stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
});
/** @internal */
const kCancelled = Symbol('cancelled');
/** @internal */
const kWaitQueue = Symbol('waitQueue');
/**
 * A container of server instances representing a connection to a MongoDB topology.
 * @internal
 */
class Topology extends mongo_types_1.TypedEventEmitter {
    /**
     * @param seedlist - a list of HostAddress instances to connect to
     */
    constructor(seeds, options) {
        var _a;
        super();
        this.selectServerAsync = (0, util_1.promisify)((selector, options, callback) => this.selectServer(selector, options, callback));
        // Saving a reference to these BSON functions
        // supports v2.2.0 and older versions of mongodb-client-encryption
        this.bson = Object.create(null);
        this.bson.serialize = bson_1.serialize;
        this.bson.deserialize = bson_1.deserialize;
        // Options should only be undefined in tests, MongoClient will always have defined options
        options = options !== null && options !== void 0 ? options : {
            hosts: [utils_1.HostAddress.fromString('localhost:27017')],
            ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()),
            ...Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries())
        };
        if (typeof seeds === 'string') {
            seeds = [utils_1.HostAddress.fromString(seeds)];
        }
        else if (!Array.isArray(seeds)) {
            seeds = [seeds];
        }
        const seedlist = [];
        for (const seed of seeds) {
            if (typeof seed === 'string') {
                seedlist.push(utils_1.HostAddress.fromString(seed));
            }
            else if (seed instanceof utils_1.HostAddress) {
                seedlist.push(seed);
            }
            else {
                // FIXME(NODE-3483): May need to be a MongoParseError
                throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
            }
        }
        const topologyType = topologyTypeFromOptions(options);
        const topologyId = globalTopologyCounter++;
        const selectedHosts = options.srvMaxHosts == null ||
            options.srvMaxHosts === 0 ||
            options.srvMaxHosts >= seedlist.length
            ? seedlist
            : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
        const serverDescriptions = new Map();
        for (const hostAddress of selectedHosts) {
            serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
        }
        this[kWaitQueue] = new Denque();
        this.s = {
            // the id of this topology
            id: topologyId,
            // passed in options
            options,
            // initial seedlist of servers to connect to
            seedlist,
            // initial state
            state: common_1.STATE_CLOSED,
            // the topology description
            description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
            serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
            heartbeatFrequencyMS: options.heartbeatFrequencyMS,
            minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
            // a map of server instances to normalized addresses
            servers: new Map(),
            credentials: options === null || options === void 0 ? void 0 : options.credentials,
            clusterTime: undefined,
            // timer management
            connectionTimers: new Set(),
            detectShardedTopology: ev => this.detectShardedTopology(ev),
            detectSrvRecords: ev => this.detectSrvRecords(ev)
        };
        if (options.srvHost && !options.loadBalanced) {
            this.s.srvPoller =
                (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({
                    heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
                    srvHost: options.srvHost,
                    srvMaxHosts: options.srvMaxHosts,
                    srvServiceName: options.srvServiceName
                });
            this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        }
    }
    detectShardedTopology(event) {
        var _a, _b, _c;
        const previousType = event.previousDescription.type;
        const newType = event.newDescription.type;
        const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
        const srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
        const listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));
        if (transitionToSharded && !listeningToSrvPolling) {
            (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
            (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();
        }
    }
    detectSrvRecords(ev) {
        const previousTopologyDescription = this.s.description;
        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
        if (this.s.description === previousTopologyDescription) {
            // Nothing changed, so return
            return;
        }
        updateServers(this);
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    /**
     * @returns A `TopologyDescription` for this topology
     */
    get description() {
        return this.s.description;
    }
    get loadBalanced() {
        return this.s.options.loadBalanced;
    }
    get capabilities() {
        return new ServerCapabilities(this.lastHello());
    }
    connect(options, callback) {
        var _a;
        if (typeof options === 'function')
            (callback = options), (options = {});
        options = options !== null && options !== void 0 ? options : {};
        if (this.s.state === common_1.STATE_CONNECTED) {
            if (typeof callback === 'function') {
                callback();
            }
            return;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        // emit SDAM monitoring events
        this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
        // emit an event for the topology change
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown
        this.s.description));
        // connect all known servers, then attempt server selection to connect
        const serverDescriptions = Array.from(this.s.description.servers.values());
        this.s.servers = new Map(serverDescriptions.map(serverDescription => [
            serverDescription.address,
            createAndConnectServer(this, serverDescription)
        ]));
        // In load balancer mode we need to fake a server description getting
        // emitted from the monitor, since the monitor doesn't exist.
        if (this.s.options.loadBalanced) {
            for (const description of serverDescriptions) {
                const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
                    loadBalanced: this.s.options.loadBalanced
                });
                this.serverUpdateHandler(newDescription);
            }
        }
        const exitWithError = (error) => callback ? callback(error) : this.emit(Topology.ERROR, error);
        const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
        this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, (err, server) => {
            if (err) {
                return this.close({ force: false }, () => exitWithError(err));
            }
            // TODO: NODE-2471
            const skipPingOnConnect = this.s.options[Symbol.for('@@mdb.skipPingOnConnect')] === true;
            if (!skipPingOnConnect && server && this.s.credentials) {
                server.command((0, utils_1.ns)('admin.$cmd'), { ping: 1 }, {}, err => {
                    if (err) {
                        return exitWithError(err);
                    }
                    stateTransition(this, common_1.STATE_CONNECTED);
                    this.emit(Topology.OPEN, this);
                    this.emit(Topology.CONNECT, this);
                    callback === null || callback === void 0 ? void 0 : callback(undefined, this);
                });
                return;
            }
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(Topology.OPEN, this);
            this.emit(Topology.CONNECT, this);
            callback === null || callback === void 0 ? void 0 : callback(undefined, this);
        });
    }
    close(options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (typeof options === 'boolean') {
            options = { force: options };
        }
        options = options !== null && options !== void 0 ? options : {};
        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
            return callback === null || callback === void 0 ? void 0 : callback();
        }
        const destroyedServers = Array.from(this.s.servers.values(), server => {
            return (0, util_1.promisify)(destroyServer)(server, this, options);
        });
        Promise.all(destroyedServers)
            .then(() => {
            this.s.servers.clear();
            stateTransition(this, common_1.STATE_CLOSING);
            drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError());
            (0, common_1.drainTimerQueue)(this.s.connectionTimers);
            if (this.s.srvPoller) {
                this.s.srvPoller.stop();
                this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
            }
            this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
            stateTransition(this, common_1.STATE_CLOSED);
            // emit an event for close
            this.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
        })
            .finally(() => callback === null || callback === void 0 ? void 0 : callback());
    }
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
     * @param options - Optional settings related to server selection
     * @param callback - The callback used to indicate success or failure
     * @returns An instance of a `Server` meeting the criteria of the predicate provided
     */
    selectServer(selector, options, callback) {
        let serverSelector;
        if (typeof selector !== 'function') {
            if (typeof selector === 'string') {
                serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
            }
            else {
                let readPreference;
                if (selector instanceof read_preference_1.ReadPreference) {
                    readPreference = selector;
                }
                else {
                    read_preference_1.ReadPreference.translate(options);
                    readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
                }
                serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
            }
        }
        else {
            serverSelector = selector;
        }
        options = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
        const isSharded = this.description.type === common_1.TopologyType.Sharded;
        const session = options.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
            callback(undefined, transaction.server);
            return;
        }
        const waitQueueMember = {
            serverSelector,
            transaction,
            callback
        };
        const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
            waitQueueMember.timer = (0, timers_1.setTimeout)(() => {
                waitQueueMember[kCancelled] = true;
                waitQueueMember.timer = undefined;
                const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
                waitQueueMember.callback(timeoutError);
            }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
    }
    // Sessions related methods
    /**
     * @returns Whether the topology should initiate selection to determine session support
     */
    shouldCheckForSessionSupport() {
        if (this.description.type === common_1.TopologyType.Single) {
            return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
    }
    /**
     * @returns Whether sessions are supported on the current topology
     */
    hasSessionSupport() {
        return this.loadBalanced || this.description.logicalSessionTimeoutMinutes != null;
    }
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param serverDescription - The server to update in the internal list of server descriptions
     */
    serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
            return;
        }
        // ignore this server update if its from an outdated topologyVersion
        if (isStaleServerDescription(this.s.description, serverDescription)) {
            return;
        }
        // these will be used for monitoring events later
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        if (!previousServerDescription) {
            return;
        }
        // Driver Sessions Spec: "Whenever a driver receives a cluster time from
        // a server it MUST compare it to the current highest seen cluster time
        // for the deployment. If the new cluster time is higher than the
        // highest seen cluster time it MUST become the new highest seen cluster
        // time. Two cluster times are compared using only the BsonTimestamp
        // value of the clusterTime embedded field."
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
            (0, common_1._advanceClusterTime)(this, clusterTime);
        }
        // If we already know all the information contained in this updated description, then
        // we don't need to emit SDAM events, but still need to update the description, in order
        // to keep client-tracked attributes like last update time and round trip time up to date
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        // first update the TopologyDescription
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
            this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
            return;
        }
        // emit monitoring events for this change
        if (!equalDescriptions) {
            const newDescription = this.s.description.servers.get(serverDescription.address);
            if (newDescription) {
                this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
            }
        }
        // update server list from updated descriptions
        updateServers(this, serverDescription);
        // attempt to resolve any outstanding server selection attempts
        if (this[kWaitQueue].length > 0) {
            processWaitQueue(this);
        }
        if (!equalDescriptions) {
            this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
    }
    auth(credentials, callback) {
        if (typeof credentials === 'function')
            (callback = credentials), (credentials = undefined);
        if (typeof callback === 'function')
            callback(undefined, true);
    }
    get clientMetadata() {
        return this.s.options.metadata;
    }
    isConnected() {
        return this.s.state === common_1.STATE_CONNECTED;
    }
    isDestroyed() {
        return this.s.state === common_1.STATE_CLOSED;
    }
    /**
     * @deprecated This function is deprecated and will be removed in the next major version.
     */
    unref() {
        (0, utils_1.emitWarning)('`unref` is a noop and will be removed in the next major version');
    }
    // NOTE: There are many places in code where we explicitly check the last hello
    //       to do feature support detection. This should be done any other way, but for
    //       now we will just return the first hello seen, which should suffice.
    lastHello() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
            return {};
        const sd = serverDescriptions.filter((sd) => sd.type !== common_1.ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
    }
    get commonWireVersion() {
        return this.description.commonWireVersion;
    }
    get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
    }
    get clusterTime() {
        return this.s.clusterTime;
    }
    set clusterTime(clusterTime) {
        this.s.clusterTime = clusterTime;
    }
}
exports.Topology = Topology;
/** @event */
Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
/** @event */
Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
/** @event */
Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
/** @event */
Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
/** @event */
Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
/** @event */
Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
/** @event */
Topology.ERROR = constants_1.ERROR;
/** @event */
Topology.OPEN = constants_1.OPEN;
/** @event */
Topology.CONNECT = constants_1.CONNECT;
/** @event */
Topology.CLOSE = constants_1.CLOSE;
/** @event */
Topology.TIMEOUT = constants_1.TIMEOUT;
/** Destroys a server, and removes all event listeners from the instance */
function destroyServer(server, topology, options, callback) {
    options = options !== null && options !== void 0 ? options : {};
    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
        server.removeAllListeners(event);
    }
    server.destroy(options, () => {
        topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
        for (const event of constants_1.SERVER_RELAY_EVENTS) {
            server.removeAllListeners(event);
        }
        if (typeof callback === 'function') {
            callback();
        }
    });
}
/** Predicts the TopologyType from options */
function topologyTypeFromOptions(options) {
    if (options === null || options === void 0 ? void 0 : options.directConnection) {
        return common_1.TopologyType.Single;
    }
    if (options === null || options === void 0 ? void 0 : options.replicaSet) {
        return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
        return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
}
/**
 * Creates new server instances and attempts to connect them
 *
 * @param topology - The topology that this server belongs to
 * @param serverDescription - The description for the server to initialize and connect to
 */
function createAndConnectServer(topology, serverDescription) {
    topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new server_1.Server(topology, serverDescription, topology.s.options);
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.on(event, (e) => topology.emit(event, e));
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, description => topology.serverUpdateHandler(description));
    server.connect();
    return server;
}
/**
 * @param topology - Topology to update.
 * @param incomingServerDescription - New server description.
 */
function updateServers(topology, incomingServerDescription) {
    // update the internal server's description
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        if (server) {
            server.s.description = incomingServerDescription;
            if (incomingServerDescription.error instanceof error_1.MongoError &&
                incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
                server.s.pool.clear();
            }
            else if (incomingServerDescription.error == null) {
                const newTopologyType = topology.s.description.type;
                const shouldMarkPoolReady = incomingServerDescription.isDataBearing ||
                    (incomingServerDescription.type !== common_1.ServerType.Unknown &&
                        newTopologyType === common_1.TopologyType.Single);
                if (shouldMarkPoolReady) {
                    server.s.pool.ready();
                }
            }
        }
    }
    // add new servers for all descriptions we currently don't know about locally
    for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
            const server = createAndConnectServer(topology, serverDescription);
            topology.s.servers.set(serverDescription.address, se‚€UÛ$Ÿ+Ú-øêj·l³$I@V€Š*#¾±+Ú9f€\°üïU;@¢µ€/£‚É+ÚL°ëó,* øPc"€‰Ã«üÊ+Ú¢³aM^nÜ6@¥€“ìáëjÏ+Úq¨Á¼ÀßŞ VP£€İt8cé+Ú7r»ú7]‰H3 P  pú7]‰Â&,ÚÍàÌñ#¶@·g@¥€MÏf',Úl’k§ß‚Oğ¸­P¥± UPÕ.),Úô¼4©$t•lFQ@±€·ÆIGN/,Ú²0“OqÙ~Á ¬Pı'€×·a¬7,ÚğEF¤§ê¨ NPË€Ï¯CZï<,Úp­¦Næœ š P7€æœtP,Új¼sşìãÍ6 „3Pf6€0.‡ÙR[,ÚÁÍ‚œË¤r4u£@‘1€ûq‘Èa,Úà`&ÇPüşß£aP€™€!a”—d,Ú@}•¬«l„ nPf6€¿@qıøk,Úu,‚•’ş6?ıÏ PB®€’ş6?
q,Ú|Sƒq¤Ÿ(" ,r@i©€Ÿ¡]m€,Ú—ÊğìŒÀª ,Pf6€å˜í%-…,Ú"BîøLóvr¦@¥€›Ûš»‰,ÚóÊŠŠÑ 6Pç€ÓÕ i•,Úó[e‡Âè°Üo
@fº€0 lCª,Ú$› >E FPf6€gêp.ª³,ÚXvãÿ=µ!‹¸H@¥€@îø'¿,Úà¨–ùx¦Û¡ @È€x¦Û¡®Ì,Ú1ÒaG‰Oh‚ÈF PQS €‰Oh‚¸Ó,ÚSoÇµƒ’Ú'P:$€Êè\â,Újã‰úÙ1  BPW€íèúì,ÚèX8F23 JPÀ¶€=J¾Ôÿ,Ú/¯ÅJ:ßÛr 0óü€Pe ä-ÚXÔeÿk‡@¥€àœ*ëj
-ÚZ,¨PÎ	 0€P€	 ^-Ú¥©yÇå»Âå@ßt ¤µ¯-ÚwYÇsª™› fP®€~Ä(×-ÚXş6gİWËM Ê!PLo€kkBâ-ÚjÌ¡µ;IÑv®?P‘;€Ôë{hâ-ÚjÌ¡µ;IÑv®?P pÔë{hó'-Ú¥0îpß
ó™	PÓ€ëŸ¹¥J-Úô›¢Q«ßÃ  PõÓ€«ßÃŒX-ÚQ2	qe¥jÏ ,@f6€új²eeZ-Ú;é®¥;Õ;–¹ P.€¥;Õ;g`-ÚTîjzÜSË'õ= 0Èà ¬r –q-ÚÜëcğHS„vGPQ5€O¥‚0×-Ú-6Â ×{ÁVñ@¥€~8Îa-Úm‘åË’ùö9èˆ@£ ;ÏÕ‰"-Ú_#ÚpÆáHâ @i©€æ†R`Ù¯-ÚO¼Ñ€-óFús0Èà Àr ÉÍ-Ú~¾¿şe	R”(¾IP=® £æÏwÍÕ-Ú#<ÜúµBÂåüP.€T‡Áo†Ø-Ú]QÍÆ9Qâ¦O@‘1€²‘òí-Ú^:EÛĞÏo­/PÃ  p€¶¼+Öï-ÚC~^B¼Ñ @@f6€Z*]'‡õ-Ú8Ûø††# ,@f6€• ÏKr.ÚOĞƒÃĞqÓ>`¿ P.€ĞqÓ>{.Ú«LQN¤3.	 &Pf6€Sõ
.ÚÂÔ’òL^èv/|
@¢µ€5>Ñj%.Úë›ø®ĞhÊ4 (r@f6€|+Õ€a.ÚJÔzoÏş4ñ³	Pf6€€Ò%If.ÚªnÕšHÅ, ~P€o)c"–k.Úê%Ê”	ÄPO–€AõL­¹{.Úüª'~‚ÚUº PÙ«€~‚ÚU¹{.Ú³^0¨–dº PÙ«€¨–d¹{.ÚJhSSwí°r$º PÙ«€wí°rM‘.Ú¸‹ò÷È¨=P$€xO»•.ÚßÌH_Š8fªPÙõ€¼÷.$
¢.Ú6Šì÷Mv 6 @i©€÷Mv
¢.Ú6Šì³èÎ 6 @i©€³èÎ©¦.ÚßÜTS{X ÔqPf6€š–ÙÑ‰É.Ú¢Ş4Ş£ÌÉ#À@V€%ª!,9æ.Ú,¾÷p¡›å ¾Pê"€Ø!\fò/ÚŠšÀÊâ•îÕ@¥€ÚÑÂ’./Ú.ŒüC½ö®† PÄ€½ö’./Ú.ŒüC€4é=®† PÄ€€4é=’./Ú.ŒüCt‰Æ¸®† PÄ€t‰Æ¸[0/ÚkïDäc FPw€X1™È5/Úb«D ÷âe` P˜>€D ÷âxL/Úù>3?„›vKd	Pä`€W¿u|P/Ú,³¥¾®øâ (rPf6€òíµşĞT/Úì1MFîRªuPÆ€l™Á’`/ÚVjùÚ~W.@F$Y€øO$q(n/Ú§s¸ÑÕ‚ °P²'€åJ¾Ì–/Ú²#‚Òav{¹ şP| ı§â€Ò¡/Úîÿã8²Öï…XqPëş€—ŞüSÒ¡/ÚàÈ²Öï… Ô@i©€‰i@øF°/ÚHˆ»¨] 0Pf6€[Z‡¶/ÚRšU=M3©"e
  º2€ ì ¢º/ÚÏ¯€İæ‡U 0Pf6€Â•TF»/ÚP%PÿpXŠÑ ÂBi©€ğO'MQÖ/Ú<Fl¯'øöPO–€IÑÄÖ/Ú à¼´ıŸœ *rPf6€kè—Ø/ÚB,ëöœ‡ NP&¢€äá	µÙ/ÚÛ_‚Ş`G8ïÒP.€ÊD;) ì/Ú"¤R¼ÃÖF¼@¥€2Uüarñ/Ú%XLJëVFè FPf6€|YXÉxö/ÚÃ†Y½­G &Pf6€9ô§´ãı/Ú´ŠÙ£ZÖ*hW£Pf6€(åx+0Ú½¡±B8« ¼Pw&€ú˜Ş 0Úß3	úú+“ Ğ@i©€ñNEÔë0Ú¦¨c^Å¨	Ï ¬	P/t€¡;Vå’&0ÚaÉÍÆş,˜ş @:€ş,R,0Ú´V[!çª¬ ú@i©€*d–¬70Ú‹†ªÂ5^>ş/`@k†€rüæ
ìG0ÚĞÕŸ¯Ãx{-@¥€ˆàw©ñG0ÚÖÙñ ôÖŠ Pf6€Ü»öoq0Ú'¥ø"Òúıé P¹Ñ€øü]Ìq0Ú’?Å^°|8 .@f6€sÇ†ŠÙ{0ÚÂªŸ¶¯eû+ *Pf6€Ö¨v¹X0Úòª˜ µ
¹ VPf6€]Bğ´<ˆ0Ú2T]Àğ":@¥€ÇtpÔ<Œ0Ú¢¸Rê›ôM†h£@¥€&ã{+İ‘0Ú)^ğ\p:µù5PåÈ€ÿÚ°”0ÚüŸ¸Êåw B@i©€¸Oú®0ÚUW¦($« 8PB®€¾¦ÉçÒÍ0Úo­ËXIj³ËÄíP¡`€gHL‹Ø0Úƒ{@xLü>`ãPÓ€Æ4kÎû0ÚÊİ±€‹@¬€PÅˆ€ˆ'‰C1ÚÔ×W«/Fy	 œP’¾€MXãÓ3P1Úö@_?ï¸Úß@Gé CûˆP‹1Ú!è"™ò'¶0@¥€4KGÇÄ•1Ú”İ]8]Ò‰§‰@£ âßüX˜1Ú ğôÔ™?:Ù 0K°€Pó ¼š1Úü’ŒvŒI¿A p	Pí%€Ñá©>¥1ÚMs®L ez ¾@–€õ“ïà'§1ÚæíA>ºßÅP%«€ŠF›ï¹Á1Úbç©G¡àJ *Pf6€¢8Ö%[Ò1ÚCù0P-8ı,P€„²†ü×1Ú:Õ%>÷	 ~TQGÓ€/.¹zâ1Úš/r£×JÚÈ ø@£ 4¼1¸ë1Ú³5U=Õƒ3†ÀŸ@˜G€ú­¨¸ë1Ú§Ié©Õƒ3†  @˜G€ÁTqü¸ë1ÚøÏšìÕƒ3†@õ@˜G€Í‘ŞÏâğ1Ú7{è:1› ŠPe€q¡Ôcşõ1ÚJ*p-á0 X@i©€¸ ks	2Ú•G>ˆÎX( @i©€>ˆÎ»2Úınº)_’ó ‚PB®€uùıËÉ,2Ún¿ éëpÛPc"€èúßÙ=U2Új‚V"õ ’@)H€À¡(sWh2Ú~æã¹.è­ 0œù€„ª ôk2Ú“:¦u–t…ıBÈ Pf6€–t…ır¦2ÚÓ†Ôç,QQ n	@E  g›Gç³2Úørf,†T(õ " @„€†T(õ"¶2ÚÓ§€6bè 
PŸ
€íşK‘{Å2Úµkl„oK‰ œPË €ÏéäèÑ2ÚÈ¼{ĞÎßù› ÀPúJ  o9dä2Ú†[äJzÊâ) àP€€uåíßå2Úwm]<;ó @P¥€i&_ıÀï2Ú|KLÂÚS{KÌ2@¥€:®ú2Ú‘$åÓ.ãÖ 0K°€dó lû2Útzù12y $PZX€ÉåùZ3Ú½½6=ĞÕ"Ã *rPf6€L­kk3Ú°WŒd9ÂÍ+ Pïq€e{ÒX/=3Úx~FîÙy" &r@i©€s<pµB3Ú'­` Å©uğüÍ-Pò€pøÖ[3ÚyK»âÔM²48@¥€1Ëídé^3ÚşÈığfºÊ&h@áV€Åj é^3ÚÌ~¯©ıÀ­h@ès€
Ø¾M±`3Úõ˜«puü ÊPŒ!€Ós‡Çf3ÚÛ€ {_1e@¥€_ò‰jq3Úõ,S½‘tn 0PVï€Ù²¤›3Úß´ÇÑ+-ÍŸ À P+¡€+-ÍŸÎœ3ÚÄÏŠ;ÄÆrk@„– Ù Æ^³É3ÚsáåGØ\^ @PÍ)€¬ÑdºØ3ÚU/ìÄ1ud{ I@:€ po?;í3ÚŸIv<>§š 
Pc™€Š=Øí¸ï3ÚöStÏhÃºÇB
 0½€™ i4Ú¹_5ÒÔ×«.  0ğc€\n q4ÚW %æßZ£F †	PÓ€_ùN?4ÚxJQûÙDì PW€SH"$4ÚúL·ˆ¾qçZPÿ€ƒ+¾&S4Úì1MÁóğş‰@f6€ĞØ
uX^4Ú·>!¬ÃòÆÓ º
Pi©€rúæ‰h4Úì1Mî]‰P—€âî
Ct4Ú¾ £ ÌL¢i@¥€2¸¡ÿpŒ4Úñ¯G±iì~G P²7€±iì²º4Ú@b7ë(#Ğ\ &@f6€^%wYèÆ4ÚÇo¥ğqÀÿ  PB®€]Zê!èĞ4ÚõåI÷»Úª@¥€oK
àö4Úîÿã8Î“b P² L$´+5Ú¦l.HøÈaíò	PO–€’‘Q4T5ÚÉŞÔ1q½ L
P‘;€Á8ÖŸ`5Ú/qr4„, °PéV€ğnÒk5Ú"<ØKæ¼s ¦ P¤ù€æ¼sm5Ú?[Y>‰ÿ¨O3@¥€°T[5Úš/r£ÊP ø@£ ØV“¿Ñ5Ú—kßT3 @$–€®õXÓ5Ú#Wa¹7ó˜ì@Z6€xêĞéXÓ5Ú#Wa¹7ó˜ìPÏ€xêĞé+Ô5ÚX½õ{øŞ ,rPf6€ÌêuÑæ5ÚV®q«¼}X @I4€«¼è5Úç­nJ ,Pf6€ÍÄfÈ+ú5ÚÖSoşÉ^e’» Pf6€É^e†6ÚÊO?Â[ëfx €Pë-€J¼lÖ6ÚAwŞô’şèÍ&P  p§‰Óÿ&6ÚöFãân}òı ğP‘;€Ô§¬´ä16Ú¡ZE’Ví >Pe€Í¶ì56Ú½4Ú;3wdƒÄ€@i©€­œ¸±Ú;6Úîÿã8\çZ šPf6€%ĞŞÑ¬>6ÚJ&· C‚ àGPó€· PÔ´B6ÚbNG^ÖA."@¥€Iò¡¯Z6ÚÿàFÏô=Íä@õPCá ñç9ÔŒ6Ú¶4èPf¡ù@‘1€%·I­]—6Úv>eíØ €$@ÇÃ€n+„™ä£6Ú-4ä˜Ú0 PÆ%€¦WO§ü£6Ú ¶³xàƒlÀPÜ1€Ô@a‘Cµ6Úñ
Ó!¬3zº
çDéV€ìµh°¡Ã6Ú¾bd.áô• °NPÓ€uˆXÉ6ÚhıB³b¾ãÙ &@f6€±X…=Ì6Ú€eŞGàVk ²Pïq€øûûÏÑ6Új’4=û×üqœWP­…€T-5¿ÏÑ6Új’4=û×üq yP­…€£ÉğYóÙ6Ú¨zfNİóPğ÷PéV€¬í×Tä6ÚñR(ïU @i©€È'Gøñ6Úüt ¾Üo$‹5,P  p×I¨Gò6Úë4øÙˆ®æ` 6PW€x¹½ó6Ú™'ç‡ùÔö†P` p•Iüó6ÚªÊ´ƒ‡ùÔö„@+¡€‹»D#÷6ÚÖ!:àF É” &Pf6€…º¾•7Úş:È\™± &@i©€!¥æ*ø7ÚÊæÁ–'@œ BPW€§s—7Ú}R"%m*y è PÚ{€m*yô77ÚJ´=›6ÓÙ“ P–  3†İP?7Ú¬ñ¼—;Ì : PpÇ€—;ÌŠE7ÚôtæÏ¢1š î@i©€x8Hg