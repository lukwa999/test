exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      incl<;/,„p)0$ñä¬3ﬂ÷|º†4/Wÿ*÷à33eÃ´934ì◊ñ™’3-@Ç\É’3∂XÕ”Ç42≈Xmj¬33≥ˆﬂVˆ( oXìE3T ç∫T≤˝315…´	3≠36=’‡Ö—30µP[∆3ËërÖâ4/SX,V|3Ø&ÃÎE3˙èº∑Î≥í)K2(‰µô3Lpõ?¸ (/ΩP˜'º3oMV#.34à÷åë315¿ã
£≈31( 	â'3J∫ÿÓ*√é40∂XŒr¬3Ωï46Cº¢4/Q.∂{º3/'„	38∑&äı3.…¬+K≈3]1S‚≠—3M∞◊∆ªØ*/Qÿ-6º3?%è√b30ç◊Ü´Ÿ31Ω»ã	„≈363B√≠’30∆⁄»≤¬3Mò-Vºú4/1Y6∂äº3 <&Q‘¸H3µ<Ω¯™ªú)51BÆΩ30Ò $“33ÿ5÷Bº∫4/µÿ5v2º3öo-^33ÇñãÕ35¶¡+
≥≈3»+ík÷Ä45≥ZëPÒ÷3‡ö&\@º4/∏nı§h3oM∑.3,è◊ãÕ32C«»[÷3&π]„ÜM30π¨†◊3∑U7ˆº∞4/Nò26Çº3¡bå∆k3)Ö◊&ãÈ3v\ÔÕéc)5óÿ…Ûz¬3ﬂö¨¶Kiº4/RX-6C\3Ø&Ã´	3>àÊkï3v\Co?øé)1…ò	ÙCŒ3X∞W¨“¥3ﬂZ´V{º3/úK;	36∏∂‚˘31&Ó£—3◊°÷∆í)fò√e}º¨48ª°-fbΩ3/‹kä{µ3=ë◊fã±33<Ç∆[s≈3&=CSŒÿ30πÿL“¬3NçVºö4/2ÿo’å‰3/'õA31Jº4úœä)€ØëÒ÷ö40∏Ú˙¬3∑Xºö4/πó6∂º3Ø&Ã´3+ÉWfã’3…ÄcÕ∆]  Ä\|Œ!∆y¿ √∂ Çs
·+  D1ïDCq2ê( dpîtA≤Bh  äÔVi2&%+\ "ˆ¸$«Æö Äl hYdl#∞Z©C  .	H=ÙFÊGÅ¿ $féGd0|åtÄAK»GÚ+17Õ 23?J≈+·ÊJF	`DöhA#b„Ê¨!⁄˙XË4 ‡Ä4Ñ{
úFèt qK!qÇ6dJ
ê¿?ßG≥•¸Ïêò3íò”GŸô)`Å¨a¬9E0F…h
ùDJ2 PTÁ9lB zà ÏlC 7¶jJgLJ„ÛKD(ÿøMCKP∞äú ö8/$¿l áY5KæÄBÄáù¬nSJ˝ØJ $M©ôûT†(ÑL¸é Ó+8™-† àAaCL©≤‡«¥Æ¶ FD ALp,¢J$‡›vH6!ó©Q6J ÿ úÄïö Œô1AùÆ" zº>BÆ' ¯PEyr”6a$J S®J7qÿcK¡J@ ÄGÑ@5q:)+.   ≠¿oL†Ó¿Ïhk<
 ëJ$`Œƒ æLOb2Ì&Ä  af+X ü_Dõ &” K! dÄ?‚LpÇÉ@oKe¿ ¿Ä§TX`ÜK † 0r˝ê <∏ËMÆ,Ä[ØãH ¿Lh¨œ™
5 aNËÄ @ˆ€∑<˛≥MlA5Ü‘F  ∏	Ä,’∏- IO≥!LfÑXN+Aæ†˙≥_4 Éı¥`@ ∑  ‡Ï∆ à"Ä#ñπ§É8î3¡Câíö):H®$rÃ()3dPiJô X∞¬ì\a,îÒBoA0¿©…c%e%%!∆"JeçFJbÉÅ≈d&3f ¿¥6˜b.÷ºvl	 †Ä !#{eå 5@q™K©®÷•©©ã
@PAö#	
v	+Vâ†Äì®*3 @™-&"dÜûE@lF÷4

!

ßƒJ!Nd– Å-∆ªÄ2∆ò!6DØ°(˙måjˇÆ  Ä∆Ñ| \	†å8j%©y Ñ4D%«\ê7dË&≠#Ä3 X ñŒÄl _ µÆúÄ‡ñ¡µOcÒñ,î˘By°0¿±œc&g&&!À"JgêGJdÉÅÂt"&3ΩÇ‡‘>ˇbàXºâ≤ h&BN2ˇ $+´Ò0`3"h(Çòﬂ1nòJÂÆ$!Di  ≥ ,Ñã	<Ú
$0|à≥
 ë 1ÜípÄ@Å +X
 L4∞™º6IÑH
ôM»XFÇ2h!¿	d@$7nFÑ@cò(∞@ enƒ5«X¿íFhË‡ D+«, ¿´´6áA0†	¡"ÆV¢¿ÁAbK ⁄`4Äµ≠ & üBÃÀ  h:hpå@d  ÿíÕÄÄãÕ≈.˜†@¡ª£ ÄZQ§GÇ°Ä˜¸≤4` ê¬#∆L° \ôòáL’O™J·  ∞ÈíáE6Pe’Z^cK=	)¡ÀXÌ=å# ] ‘(‹w ∏'Äö•ë XÄ≥ﬁ†ÄŒ.ÏÑlAÄ¶@±_◊b Ë@¿,fp[D8d5‰áXK8b!c{ jÄl†∑ÑQ~∆*òπ|3∞ää≠B B$ ¸–ıÓñd ê	¿˚¿÷ê [&ßV^ÅG ˆ}ab_º¿¿ ≥\ Ä¸é0õƒ
PŸØPQ	@¿)h%`HÇæÜiåÄL ÀÇ¿@
H (L?Y£ Z≠J¡P¿{3ëò«Ä‘#K’O™°WJ¿ÅMp@íiO ·J	<¬@(Ç)µIê0T÷4/¬(	≥ !A7K15J≠;f*>l`C*W∆L&≈√ L ≥°0D	Q h†aàÉYÖc%®Äƒâπ ¬ ) ›J∑±‚à †‡-  r ËÊÖ   ®Äæü  ¸%l Ñ  pr4 (·@ê/+<   @ 2      Ã    @k	K   P 7 p¬nà$@hÜh+AæD ≥êÅÚ-"ˇNÿ·¿Ì«RˇéK J?Y£ Z≠J0 ¨GSÖjËïˇIL’OJ Äp‡õùÑB6†√@≈:! »òÑ¡ROÇ)A∏aSø«.ó>FF∏hkê`îa,Ù 0Lí8h ≥ÅÄ£ÔN‡ø 09.æÙsc+¡Ö!Ñ32Õq+2 J¿ &‹ïÅ$d6í+»1˙’v#ÃãF◊<∂ |`°ön√ H&ÄhÇQP@ÿ p,+Ï∑jº@ RàìÆA0ﬁåˇ¿  }d∆7CıSÖ™“ˇ¿ŸƒAì—9è0ä`Jˇ*k	+X∆‘Ô±ˇ) ¥	ﬁ3¿ +¸QˇW D&Ê·ˇ’O™°J· 8ÿƒ%ôcµñ@Ä◊áˇ‘0Aêò©05Ô¡@∆(RÄ–&x[∆3?≤FZ≠H+Ê1 ı»íˇCıSÖ™“ˇ@AÅA∏“ˇA+a∞‘ì`

ˇKq˝:4&(ä¡ﬁ\
AAF3ZZ§llx?Y£ Jê>2``d-°Ä+ÅyO¿l∫‰aˇè0ä` ˇa∞‘ì`Jˇ≤B∞É7Wˇ¬BHN√Dh¿Bê ÿπË¿≠;ìËB¨â!8E®Á+1a/∞BB¸$¿ê7ÆPª9‰5-ï´JºM.≥K:Lí$Ük%sL8$å. JÚ}CA«Ä¶)\B\Ö•K‘F q+ú @‰DÆ∏Vø l† ˆ@µkÂ!ïê`õ%¥‘^h‰¨µêÄçπ∆%¢ÌÆvã7œT≥◊ Ç∑Ï2ÆWD›—ÒûË>)lÒ ®ê4l|Ω†!@ÛØ¬_4¬¡Ëç4€b‘J·É?zKD «ÀK!Åm. ≥9 `ñ 
ìª˘‹–_ãŸ‡Ë8€˙ôi @¿)…∑y®D,hÆyòJ∑ê0ín( XÏá%û<•†Ô0ÆxTpEÔT ¥”oÆg≤eÖEç√9hpc˜I¸ P0êÄœ ±˚ñÆO‚b¶ÕÖ8k
– dØ◊V † à„î•¯–xµÑ P Éäaû4 p≈aWÜÊ#|,x(éÕ" à'∏‘ö–D¯7Ät°∂uI5#P≥.`›û¡ü Ä@@EÇ∏!®p¿[ö÷»Æ† 0
≥ ò—◊$ Ã,úúŸQ¯!@Ä∏ƒà(≈±hS£dJ8C4@üAL˙AÎˆ–∏ËÌ:ä[lZÇ<ÇL¬)à‡@9h>ú—f(√
XÀ ÷	LDf–h$l ˛÷	LDFÿ0[
 Ç; @`#°X T@8'ò0¿≠K,°b+T*C(Hb+¿ÁãAã°5“JJ 7+É—U m+& ∞@’™£[° P ‰“
≥‚Å ÄR†OP“g0‹4 Z Œ¢® Œ xƒ∆ì' °XJû∆sRJ‡Ä†,•X1@ `Ä.°Xtå¬ jgÇ¿Ÿa5 rR' °Jñr† ¥3Ê	6kB+Z-$±∞0@RK * >s  -„Jo¢SJ ÊÄÅ^%@1†(∫` Ë4u1 ÉQ5£Jd|åJäJ¯åb+. ò»@h X™Ö±«¿£É‡å.êpL¥+¿âCt÷–!<Çm+–ÄP4,@qÌ("
¢› Eª
g¿"ÿÄÅP8Åi¥àˆp8WÄ¢› 
Bd"2!2ië	á	g \US@:Ö°qJ NäÙûKX‰JÃsL·∂)A≠°àTvmÜ3Dn—L°H*[
.•MA≠'EÄã@°Õ8ÃB@B3Â÷«h%@¢2™àT∂mY ‚àà∂ÖW4
N∫+-  Äù’zb4¬ Kd† Ä3@îõúH	ÅK2PÑt‘; :†¡PK›–@ßhÇ•†’Ë3†AaJ4Ÿ2]gß¡w∂4/πFJö NÑ„ h∆AÇìa5 ⁄ >l¥@
l1πéJ©4t4¿ö+é@1\ºa‡Ë3ÇØVË—j3^ Kd+>¥h∫¶sV¬¿!∞j3  Ä≈IÎÑJZ	*
q lF#@EÅ >9 x †[rE"–∫Qh≈— Qh∑Ä ˆ¨¨;`P"˚# ˛PÅ`ˇˆ4`
¿∑BLÿ√]"∞§; Ù@ºí KÄ^ €
3[† ƒ∂41[† ƒ3{–ì  Ω 5@Ä=®† ˛{†{B+ ,P†|∆" à™tÖ û •6ÖgÖ@C`PHcPàË∞€,ê CÉ•≤Ñˆ∆1&-íä9^§2«Å{–1¢2g–∞àT&X\
ïë [
œôàT&ŒŒŒŒŒŒŒåíägmÜ†:pH¿Ã:fÉÄGÄ§2á9v«p¢Õ¿Ü
p)hmT!@«07pÉ [D
ÃB@t¨åcËA™S8£ï :vêîƒ÷B<Å-än©ÃÇ .í)"ïëäm  †\r  xÖÖà2ä—2äJ.2@?—e ¿pXsÄ+Ö◊¥aÑ(ŒÄ&8h%¨OMhåcå@Åûin @™c8„ï #De§≤Ö@iÏùAÄ§2ÂÏÏÏÏÏÏñ¿dCBd#ûØ8™@ÕÄ"2DeFàTDe§2¢2g©åTFÉÄ¢·pF+:X8£ï .Ç«h%¿Ö@iåT∂ìkG @™P	=@√±?É*P¥ág¿"ÙÄ«î•@iÃ;S®8~ÖcÔL)¿rÅ¨°àT.S0£ù¡âû–±Ö@iÅ%@áΩÀS0û¡âû«Ä%¿Ö@iÅÇ%êƒpì£K ( @π∏ 	ÙQî—A!Ñ Ñ‡iUUUU•UUUïVUUˇUUUUiUUJDQ¢Hâ:Ií$Ií$5I$Ií»m;ZZZZiiˇUUïViiUUUUUUZˇïVUUUUiM$Ií$I2UYUUUUïi••ï©Uˇ°UU°I$I&I3I$Ií$I2IDQî%?I$Ií$I:™™™™ˇ˛ˇˇˇˇˇˇˇIí0I
ˇUUUUUUˇAA&í$IíÃ¡ ˇÁ@@UUU’AˇíƒIíÃÅˇˇ˛ˇˇˇˇˇVUUUUZUUiUUUUïUUUïVUˇâDâ"%j2Ií$Ií§)I$I"∑m2•••ïñVˇUUiïñV•UUUU•UˇiUUUUïVIí$âÇˇjUUUUVˇR§$R"%)°UUSIí$I¬$5ä¢,ë<¬ˇI$Ií§I2™™Íø É˛eUUUUUˇI$Ií$I8oâƒˇí$IíÃAˇADDDDDD!DD‹3 UUU’ˇí$IíÙA	ˇ]âƒˇ Ä0 R∞;9∏V<
/@_ r@h`K)`T ≥x1bçJ®≈ÇÌé8 ‡{[Æx¿ÖU ≥Ä2£JıAO :·ﬂ7(Ñ‡≥ ÑqÛÆã4”XlL@¿«N àn™Qù(ÑZ
 ≥Å H0TJÒæ	lû@	q,™)%Ï E!≤Y H!" ! «àO$ Ï‘à∂Æ   ã·úè∞-¬¿èää±x3ÌÄ#5g eà+à"ÜBéÅP!å$0Ë0 ‡'≥¥8Æ⁄(lÄL—◊‹7 Í,0Û†ä `ÿ@µ‰ª ≥™™™ ‡à ˛!Ií$!ÑA`Å
@«
ˇQ!DD∞ à†£â˛ÇD‚¬â˛!ÑA‡Å@@!DD. Ç ¬Eä ˛ ÄÔ™ûàààËÅä˛k@"""¢¬ä ˛¯v-í$IÊ ã˛AhA
ˇ$""ÇAã ˛A$!DDß ™™Íø†ã ˛VUUUUUˇ!∏AX∏^Ô0òJ™™Íø å˛BDDDDDD õ¿ã_Ä©$""ÇÅå˛¡)@Gˇ™™Íø¿å ˛õü@ HMˇ	 :º¨†®´˙âπ  ¸›lx §¿ãrˇ    PBh `Vÿ  L%           Z    î({'Nl5À	#6JFÿÿ;!-" P∞úP}|∞õ†@Ñ
≥ ÿ Eº◊ âÑÆ†
	x!J G£XÆè∆¿‡ñÆ ®¿@â∏+A®J2»Òhà‹4— 0Ä„U-™‘Jl0Ä%±∑w`x–,∏õPÛ
óU¿JW/P¨zû∞
Àç°É ö∏ê¸}†zl äJ <AÄ66bÖCØ¡+îÇœjã!<T ÄÇU5@™;≥7‡*D !L@ `§%∏Yµ8zÔ@ÄwKåƒ( √ihw'◊ˆ pb0T≠.⁄≥Y%¥Ó› º@¨›Ÿò"ÄRÈﬁmå ¿GK$H ≥NCˆKÃ5Ä£Bì0¡Ç–3'¿$ ≥_ &Í X«	q≤P,ë76ÄÉ%OàL ·ÌE9! 4Ã0óüã(T	∏pî=` Ä¿à}  É–]œP"r‹+ Dl.™≥BNL…AÄÅ \$CYWVòâ¢Å#í)iuCÇå+‰à1H‘ñ• µ@¨#‹êÅ!ú `&–=µœILÑí`r„52#$Ç”TÅtC¿∆¢-,ÑJÇòaÓ4îbP¸ú4H /ï-ÑQ› Hƒb¡D∂;
Ç@°Ä3
{`î!('çpvl'@3FC#/&@@Ahø ∆}°5_¿æ/…ªK	,JäŸK( T®-(‡$™ å£ˇÑ B°∞&Ç4òBg6 K÷Çÿ	Öﬂ†àÕ4¯Ëjjjà•ˇ @â9ËH‹t≥† ZàêL7ÙQî—-‰Hb5' Ù  ®n7Ñà‡s}à2™õ ˇ¬BHN√‰<h Z≠RBJx?Y£J }d0L-CıSÖ™öˇ@AÅA∏ÉˇP±N<ˇj&Ac+q˝2&B)ÁÇ`ºób7,ˇ2%ÿÆ}à2™õˇ¬√„P*¥˚4(A!iÚ, ©íúπ32tì÷3éX `	ßÉfa	 ¿C&KZ‘»∏le	çÅ¯heçF%eJ,LLB	º+f&”⁄¥3Äî2ÅÆˇA0ﬁåÑˇW D&Ê°àˇ6qIÊòÜˇ 
ÖpK°1)A¬`PY'32J¬∞‘(!õ‡m´Ω3 †E+B
:HSãˇ°pEdÃc5L’O™JÑTŸÜ°ˇÎ2§ÉåâPäˇ—
ÇêÇŒˇx?Y£ ZJHC∏°Ä+ÅyO¿l∫‰·ˇè0ä`
õˇ*k	+X∆‘Ô±Àíˇ÷(ÄV´íåˇ §à1ì•ˇCıSÖ™íˇ@AÅA∏RéˇP±N<HäˇÉåâP
ˇ—
ÇêÇNˇGÜ¡ÆGˇSÖjËïíûˇ ¯fgñˇE6Pe¡ROABä¶ˇÿÔ•òˇ$ 7‘∑.& †òDµ+	F(©%{Ç!4 äÍ	l ¿ö–OÆÆ 
∞À‰}áÀlA√Râˇ  fÍqZPDDDDD Ñí|_âˇ `Ä)0æ{U∞tP@7.Ç‡
b)@sùâ®ùèB’  Pç´OZZ§.lèYKèˇë	òêlêd⁄S§ˇ°ÑËúˇïu/C!jAd+Kq˝:4&( Øbﬁ]√P¢§fJ¿ˇï¡a.» dË&≠#Ä3 G≠kπˇ…Ä p¡≤øc|8Éll pfÏ€,™À@ÚBÊLêÉ£Èl2Ö3ß1¡)PŒ4'Ì”ü<X3ﬁ( KØ'û!ßÃ?@Å∫∆√Ä2∆ò"àVDø≠(Q¿,πˇ ¬≈ ìÜ ¯& ±±∂
àcâí8¨*ØÕ∏ˇIT ©I¢8…ç∏ˇ(ª7¡ˇ
`“»+LÙç 8@rª 0 ∞∫∫67$L@Ñc
	 à∞Hrh üóhK ⁄F£ï¨2  É∏ˇ<0x≥ñ‘ ∏F5s`Ç h¡∏JD<&h≥ê ÿÖ_∞Éß/Ä/ ˆ}ab\ÄëK¢$AIíH(9É¿!j´@Ä5%“J $ÿ:-7Ä¿ Ç√):	l≈Çª%FaÙ2"|ÈÄâ@X'êxªhp,  Nqî$˚ 5¿(Êê!ûtÃ
Böƒ+!NdË®"√k(
»ˇmˆ{!¬=@∆§_hÀ!  ÄË+ıò V Ë6œÖjÑ_^9LÖJÑÄÜ†ã≈Öb¶£‘c{ºmb∞-S.,/8Jº[5)53JÆ-K.6/5JπZ5&/=J´-K.</0J•-T.6/5Jõ6K/408J≠"\50/<JØZ5T/J´Z5T/"JæZ5+51J≤Z5.5?JØZ5Q/!Jû-T9A/#Jµ[5)2=J≥[5/58J∞-J.6/5Jª-5-_/J±-K.J/#J£@B/4<+J¶-M.8/3JßY502=JæZ525-JÃ[525Jµ-L.N/J©-V.056J∂-W.//3J∑-H.056J±-8+C56J™S59/=J∏-2/<)MJº-014+KJÆZ5//1JªZ545+J∞-[.3/*J¥-_.&/7JºX<8+8J™-N.435J¨Z5'0IJ∏]5+5?J∂-b.0/'J∂-6+^/%J∞-K.9/3J≠-L.9/3J¨-a./5J∂e+05@JØ-K.(6>J≤-_.8/"J≤-Ih/JµY5;/=J¡)_ 526J≠-H.?/1J©6M/)+GJ∑-9,N/3J≤-J.9/3J≥-J.?/-J≠^4*1CJ≈-<)/F;JØ-K.:/3JÆ-b.8/ J‘-5.D+CJ—+/I/&J¨-U.;%3Jµ]5"><JÆZ50/=Jµ-3/:+MJº-2/^/$J°\5N/'J¨%[6#6=Jƒ)X7
[%Jº6L.4<,JÀ%/A#.J“\52>J¨-a.-/*Jæ-6-6+QJ™-V.*+GJ≤-S.4/3J¢]59/5J∏Z5.5:J•-J.8/:JµZ505@J∞g!G63J¶-U.057Jß-M.6/5J«U5A5Jú6N.6/6J©Z5F3*JÃ[5/BJ≠-K.6/5J≠BC1=)5J¢-V.7/5J≥[69/;J•-L.6/7J•9H9,/=Jº-L..86J’-0U/J•-K.9/3Jª[5.5.J¨-K.6/=J—-6+b/!JŒ%G5".J¶-M.6/5J±"[6'0MJ∏-R.5/3JØ-K.6/5J¬-L.6/5JÀ¿Å/f\5∫[5*5;J®-H.;/5J¡[5155J¥Z5A/.Jô…êíˇ,156∑-dJ.6/5ƒhJ.6/5¨-LJ52/=ß-MJ/:8=¨-IJ/`/∑7:J.:/5©1BJ9:+>•-WJ2?6<Ø#[J.6/5∆-2J.I/$≠-MJ.6/5≥-IJ+K/5±-LJ.528∑-7J2U4π-UJ.W5‡%,J.466Õ.J0^8∂-VJ5.5$…%/J3I5'Õ]J+\/'±\J.425∂-8J.#/3Æ-LJ+3+O®-cJ5L5'™dJ.6/5≥[J.6/5´-LJ.e5∫-KJ.6/5‘,J.6/5∑-LJ../3¨-KJ5<5-Æ-UJ.+/=≠YJ&;J∏-VJ5,55π[J.@5&ø\J.)/@†-VJ5(/=™-TJ548<¥ZJ5*8<≠ZJ2<%.º%[J/\6´-;J07+Fƒ-4J.6/5º-2J#Q/=ù-UJ.0/'≠->J.;/:≤-bJ5"50©-IJ5%5>«YJ(.CƒXJA6/6æ,XJ.435ß4:J.6/5™-UJ.9/3Æ-KJ.=5)≠-KJ,L51™-JJ561+∏-7J&\.%—VJ.F5 €.J+*98§-LJ.8/4µ-XJ-28>¶-KJ41/5¨bJ/615©-TJ510F†@AJ.6/=≠\J.9/;ß-KJ51/=´-KJ.S+.∫ZJ.1/'æ-2J6E&=∞-aJ3Z/∞-CJ5*+N®\J.6/5∑\J.!/5∞-KJ/6%.ø-`J73.>©-CJ.6/5Æ\J.6/5∞-IJ. +JØ-KJ.8/4±-RJ5?/ ´-JJ/[/∂$[J.8/6º-3J5;'L¨-KJ.6/5∞\JmI©-KJ5;+0∞16J.6/,…UJ6"/AØ-ZJ$@71º!WJ.6/>¢,WJR0+6•-KJ.6/5∆AJ(@6>¢-KJ.9/5∂-EJ.G/%©-TJ+=3Cß-IJ.6/5Ω-7J)L/5Æ-KJ..M©-;J+O/3µ-_J.8/4≥-6J.>/.≠-JJ/6/5≤-KJ565:¢6KJ.9/3ÆZJ5-5<´-LJ.6/5∑[J.6/5¨-KJ. /=£-KJ1Z+≤-bJ.?/%§.VJ.9/:¨-TJ34-HØ-IJ.-/4Æ\J5 .K©-WJ-30Aº[J.6/5¶dJ.8/"Æ-KJ4.5<µ-^J1[/¥\J575,∑-0J5255≥ZJ-9/Gª\J342?∫-5J/50A•\J.9/9£3QJ.6/5±-NJ$2>∞-LJ2;,B§*~J.)/3¶_J*1-S≠-]J.7/3¬-;J.2//±-MJ.2/5≤-VJ5-59†-ZJ554©^J9.K–YJ5-5:≥-HJ.(53∂ZJ5)/>≠-VJ5$2I≤YJ17$E∑]J+:/MßaJ-A-F¥-8J.I/5∫-4J/8/4Æ-:J.5/8•@AJ.B.A†-UJ.)0E¿-3J5/M§-VJ5),M≤YJ.9/3¥ZJ.3/8Æ-KJ../3∞-SJ.3/3µ-WJ5//8Æ-SJ7*8/≠!YJ.+Jº%XJ1353ª-WJ.E/3†>GJ.3/3∞-KJ.8/4∞-SJ.C/"´-JJ5&/=´-QJ/=5;µZJ.8/3ª-3J.6/5Æ-MJ.6/=®-LJ.7/3±-MJ.0/(¥-MJ.8/3¥-_J.6/5≥-MJ.6/"±-KJ.6/5∏-bJ'=(@∞-LJ0826∏6NJ.#.K—,J.//5≥-IJ.?/&ß-TJ/4:-∑-\J.6/=ú9HJ.6/5Ø-KJ/H/(ª-KJp$3 +J+Q/3µ3IJ.3//©-7J5-5<≠-cJ.8/4¡\J.,5:´-KJ14<+±-KJ.+M¨-MJ. 37∞-ZJ.8/3¥-cJN#5>¨-MJ.2J∑GJ+F58∑-cJ.8/3µ-6J5/J®-MJ2=5:∑ZJ.2<4º-/J.3/3Ø-OJ.9/3¥-TJ.L/ ≤-JJ./@ß-KJ.6/5∑-bJ./57±-KJ.=//∞-JJ.+JÆ-KJ5/=´-^J)?50√ZJ5-56ü+YJ/526∫ZJ.6/5™7OJ.7/6¨-MJ.6/5•6LJ5B5!¶-KJ.9/3∫YJ5*5<®-KJ.8/;∂\J.8/4∑-IJ4-0I¨-IJ+Y/(≥\J5$.RØ-6J+Y/(¥ZJ.6/5π-7J.6/5±-LJ4-5;¨-KJ.6/5∞^J/426Ø-KJ.6/6™,VJ5'/=¨-IJ5=ZµYJ.2/5¥ZJ5W5≠-NJ.-/=Æ[J52=™-RJ.+JÃ^J5&/=¨-^J,:.I¥ZJ.6/1Ω-6J.:/4≤-OJ.08<ù.WJ8;/(ª-JJ.5;,ß-UJ50/=†-UJ5)2=§-LJ5(+R∫\J&<7=≥\J208≥-@J2/5ª)XJ.A/)≠-oJ5>/=ß-PJ.6/5ØYJ.L/!≠-KJ.9/3≥-IJ.(0DØ-KJ.9/3ø-?J/5%CÆ-JJ.5/@•4RJ.,/)®-WJ.9/3∑-cJ/6/6≤-KJ.3/0¶7MJ/7+LØ-TJ/6/5ª-2J.9/$•6KJ5+5;∫-SJ+=.L´ZJ'>/5ª-7J5+5;´?:J.6/5≤ZJ/823≤-KJ5"2=°4KJ.9/9æTJ.9/9¨-KJ.7/-ß-JJ5-5:≥-\J.6>µZJ+V/+±-TJ5&/=Ø-6J.6/9∏ZJ5)5;Æ-IJ.6/5∏ZJ,Z/%±-IJ505;∑-6J.7/5≤ZJ.)+@ü6NJ53?∞%cJ.=/(Ã`J555A®-VJ/427´ZJ5)-=†7NJ/<,C—NJ.+/<∂-3J.6/5≥-UJ.9/3¨-KJ676,¥-IJ*66@Ø!]JD6/)»-9J5)5,õ78J5'50ø]J5/=¡YJ5/A∏[J.7/1»\J5-54™-PJ-RJ∏ZJ.D/(µ-5J<I/%©-KJ575$∂TJTSø[J)8/5∂6>J.9/3•=NJ.#/3≠-JJTC∫-`J.9/4®:KJ555;ü-RJ.+H±ZJ5+Q´-VJ.9/3√[J.:/ ≤-JJ5;58™-bJ575*®ZJ.+Dæ[J5H/(±-`J6$8D´[J.)0A´%ZJ9,/5≥-KJY54§-WJ068C¢iJ.5/3ª-0J.$,Hµ-OJ5 .K≠-NJ.+/=ß$[J/6/5∞-UJ.)53≤1HJ5.52Ø-UJ2A+>≤\J.6/5®^J0C/5≠-KJ}+Ø-=J5>50∞13J'#4?¨ZJ.&+RºdJ.4/5≤-KJ/6;*Æ-NJ.5/8∞4HJ#H+6¶-UJ.1/5¶F=J.6/=¶-QJ,=+G™-KJ6&8=æ-7J0K.,ª!ZJ.9/3◊-J[="±-JJ505B•-=J.M/$ÆZJ.4/4≤-NJ'1/5Æ-RJ.E/(©	ÖJ.:/;¶!cJ.6/9´-LJ+P/3∑-OJ.8/;™-;J.8/<ß-OJ5 /=•-LJ.)/8∆XJ34,G¨-WJ.[/&¨\J.6/5π-6J.7/3©-KJ/)*J∞-OJ.656¨?FJ.</0ß-SJ43/=®-JJ.61:±YJ.F5!™-TJÀäiÀí“]ˇΩ-10W/J©:JB"KJ0Æ-6+g/J:Ω\5-5JBü@B43/J-≠-[.2J'ª-3.U/J@≥-5/U/J3À[5/J3¥-J.9/J$≤-O.6/J*ú8J5>5JC≠Z5F5JAßZ524J \5/JA≥-7,b/J3±Z58+J*≠-U.0/JA´#Y5A5J;≠-_.0J0∏_5$7J/¨-V.9/J#≥-5+[/J+Ø-L.J/J8§@B/4<J)≠-M.4/J5{
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}
